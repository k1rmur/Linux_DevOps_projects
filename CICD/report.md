## CI/CD by bruscoaz

## Chapter I

### Part 1. Настройка **gitlab-runner**


**== Задание ==**

##### Подними виртуальную машину *Ubuntu Server 22.04 LTS*.


![](images/0%20version.png)


##### Скачай и установи на виртуальную машину **gitlab-runner**.

Добавляем репозиторий:

`curl -L "https://packages.gitlab.com/install/repositories/runner/gitlab-runner/script.deb.sh" | sudo bash`

`sudo apt-get update`

Устанавливаем __gitlab-runner__:

`sudo apt-get install gitlab-runner`

##### Запусти **gitlab-runner** и зарегистрируй его для использования в текущем проекте (*DO6_CICD*).

Регистрируемся, вводим __токен__ и __URL__:


![](images/1%20register.png)


Далее выбираем __shell__.

### Part 2. Сборка

**== Задание ==**

#### Напиши этап для **CI** по сборке приложений из проекта *C2_SimpleBashUtils*.

##### В файле _gitlab-ci.yml_ добавь этап запуска сборки через мейк файл из проекта C2.

##### Файлы, полученные после сборки (артефакты), сохрани в произвольную директорию со сроком хранения 30 дней.

Создадим __build-job__ в которй сделаем `make` для __cat__ и __grep__ и сохраним артефакты на 30 дней: 


![](images/2%20build%20job.png)

### Part 3. Тест кодстайла

**== Задание ==**

#### Напиши этап для **CI**, который запускает скрипт кодстайла (*clang-format*).

##### Если кодстайл не прошел, то «зафейли» пайплайн.

В скрипте __clang-job__  вызываем `clang-format -n` и записываем вывод в __txt__ файл, вызываем `clang-format -i` и `clang-format -n` и записываем вывод в другой __txt__ файл и сравниваем выводы. Так же переводим поток ввода с __stderr(2)__ на __stdout(1)__. Если файлы разные, то вызываем bash-скрипт __clang-error__ и кидаем __exit 1__:


![](images/3%20clang%20job.png)


Содержимое __clang-error__.__sh__ для уведомления в телеграм:


![](images/4%20clang%20error%20sh.png)

### Part 4. Интеграционные тесты

**== Задание ==**

#### Напиши этап для **CI**, который запускает твои интеграционные тесты из того же проекта.

##### Запусти этот этап автоматически только при условии, если сборка и тест кодстайла прошли успешно.

##### Если тесты не прошли, то «зафейли» пайплайн.

##### В пайплайне отобрази вывод, что интеграционные тесты успешно прошли / провалились.

Запускаем тесты, вывод тестов записываем в файл и сравниваем со строкой, если строка отличается от `TOTAL_FAIL:0` или отсутствует(к примеру, если произошла ошибка запуска тестов), то запускаем __tests-error__.__sh__ и кидаем __exit 1__:


![](images/5%20tests%20job%20.png)


Содержимое __tests-error__.__sh__ для уведомления в телеграм:


![](images/6%20tests%20error%20sh.png)

### Part 5. Этап деплоя

**== Задание ==**

##### Подними вторую виртуальную машину *Ubuntu Server 22.04 LTS*.

#### Напиши этап для **CD**, который «разворачивает» проект на другой виртуальной машине.

##### Запусти этот этап вручную при условии, что все предыдущие этапы прошли успешно.

##### Напиши bash-скрипт, который при помощи **ssh** и **scp** копирует файлы, полученные после сборки (артефакты), в директорию */usr/local/bin* второй виртуальной машины.
*Тут тебе могут помочь знания, полученные в проекте DO2_LinuxNetwork.*

- Будь готов объяснить по скрипту, как происходит перенос.

##### В файле _gitlab-ci.yml_ добавь этап запуска написанного скрипта.

##### В случае ошибки «зафейли» пайплайн.

Для выполнения данной части необходимо прокинуть с первой виртуальной машины __ssh__ от рут-пользователя, чтобы прокинуть через __scp__ исполняемые файлы. Дальше пишем `deploy-job`, в котором сборка данного job происходит вручную, для этого мы прописываем условие `when: manual`:


![](images/7%20build%20job.png)


Содержимое __deploy__.__sh__:


![](images/8%20deploy%20sh.png)


Содержимое __succrss__.__sh__ для уведомления в телеграм:


![](images/9%20success%20sh.png)


Проверим, что на второй машине все развернулось и работает:


![](images/10%20usr%20local%20bin.png)


### Part 6. Дополнительно. Уведомления

**== Задание ==**

##### Настрой уведомления о успешном/неуспешном выполнении пайплайна через бота с именем «[твой nickname] DO6 CI/CD» в *Telegram*.

Для настройки уведомления регистрируем нового бота через __BotFather__ в телеграм, он выдает нам токен:


![](images/11%20token%20tg.png)


Далее добавляем его в группу и находим __id__ чата любым удобным способом:


![](images/12%20add%20to%20group.png)


Далее было написано 3 скрипта(см. прошлые части), в которых через __curl__ с помощью токена и id чата мы прокидывали сообщения о статусе job или пайплайна.
Теперь во время фейла одного из job-ов или успешном выполнении всего пайплайна, он пришлет уведомление в группу:


![](images/13%20output%20bot.png)